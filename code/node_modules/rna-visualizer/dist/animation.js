import * as d3 from 'd3';
import { Vector2 } from './rna/data-structures';
var SingleCoorTarget = /** @class */ (function () {
    function SingleCoorTarget(coor) {
        this.coor = coor;
    }
    SingleCoorTarget.prototype.getX = function () {
        return this.coor.x;
    };
    SingleCoorTarget.prototype.getY = function () {
        return this.coor.y;
    };
    return SingleCoorTarget;
}());
export { SingleCoorTarget };
var DoubleCoorTarget = /** @class */ (function () {
    function DoubleCoorTarget(coor1, coor2) {
        this.coor1 = coor1;
        this.coor2 = coor2;
    }
    DoubleCoorTarget.prototype.getX1 = function () {
        return this.coor1.x;
    };
    DoubleCoorTarget.prototype.getY1 = function () {
        return this.coor1.y;
    };
    DoubleCoorTarget.prototype.getX2 = function () {
        return this.coor2.x;
    };
    DoubleCoorTarget.prototype.getY2 = function () {
        return this.coor2.y;
    };
    return DoubleCoorTarget;
}());
export { DoubleCoorTarget };
var RnaPositionRecord = /** @class */ (function () {
    function RnaPositionRecord(labelLines, labelTexts, residues) {
        this.labelLines = labelLines;
        this.labelTexts = labelTexts;
        this.residues = residues;
    }
    RnaPositionRecord.fromDataContainer = function (container) {
        var labelLines = new Map();
        var labelTexts = new Map();
        var residues = new Map();
        container.residues.forEach(function (res) {
            var key = res.index.toString();
            var target = new SingleCoorTarget(res.getCoor());
            residues.set(key, target);
        });
        container.labels.forEach(function (label) {
            var key = label.residue.index.toString();
            var textTarget = new SingleCoorTarget(label.text.getCoor());
            labelTexts.set(key, textTarget);
            var lineTarget = new DoubleCoorTarget(label.line.getCoor1(), label.line.getCoor2());
            labelLines.set(key, lineTarget);
        });
        return new RnaPositionRecord(labelLines, labelTexts, residues);
    };
    RnaPositionRecord.fromTemplate = function (container, template) {
        var labelLines = new Map();
        var labelTexts = new Map();
        var residues = new Map();
        container.residues.forEach(function (res) {
            if (res.templateIndex > -1) {
                var tempRes = template.residues[res.templateIndex];
                var target = new SingleCoorTarget(tempRes.getCoor());
                var key = res.index.toString();
                residues.set(key, target);
            }
        });
        container.labels.forEach(function (label) {
            if (label.residue.templateIndex > -1) {
                var tempRes = template.residues[label.residue.templateIndex];
                var shift = Vector2.subtraction(tempRes.getCoor(), label.residue.getCoor());
                var key = label.residue.index.toString();
                var coor = Vector2.sum(label.text.getCoor(), shift);
                var textTarget = new SingleCoorTarget(coor);
                labelTexts.set(key, textTarget);
                var coor1 = Vector2.sum(label.line.getCoor1(), shift);
                var coor2 = Vector2.sum(label.line.getCoor2(), shift);
                var lineTarget = new DoubleCoorTarget(coor1, coor2);
                labelLines.set(key, lineTarget);
            }
        });
        return new RnaPositionRecord(labelLines, labelTexts, residues);
    };
    RnaPositionRecord.fromTranslation = function (container, shift) {
        var labelLines = new Map();
        var labelTexts = new Map();
        var residues = new Map();
        container.residues.forEach(function (res) {
            var coor = Vector2.sum(res.getCoor(), shift);
            var target = new SingleCoorTarget(coor);
            var key = res.index.toString();
            residues.set(key, target);
        });
        container.labels.forEach(function (label) {
            var key = label.residue.index.toString();
            var coor = Vector2.sum(label.text.getCoor(), shift);
            var textTarget = new SingleCoorTarget(coor);
            labelTexts.set(key, textTarget);
            var coor1 = Vector2.sum(label.line.getCoor1(), shift);
            var coor2 = Vector2.sum(label.line.getCoor2(), shift);
            var lineTarget = new DoubleCoorTarget(coor1, coor2);
            labelLines.set(key, lineTarget);
        });
        return new RnaPositionRecord(labelLines, labelTexts, residues);
    };
    return RnaPositionRecord;
}());
export { RnaPositionRecord };
var Animation = /** @class */ (function () {
    function Animation(container, to) {
        this.reversed = false;
        this.container = container;
        this.isActive = container.map(function (c) { return true; });
        this.to = to;
        this.updateFrom();
    }
    Animation.prototype.changeState = function (index, isActive) {
        this.isActive[index] = isActive;
    };
    Animation.prototype.changeAllStates = function (isActive) {
        this.isActive = this.isActive.map(function (e) { return isActive; });
    };
    Animation.prototype.updateFrom = function () {
        if (this.reversed) {
            this.to = this.container.map(function (c) { return RnaPositionRecord.fromDataContainer(c); });
        }
        else {
            this.from = this.container.map(function (c) { return RnaPositionRecord.fromDataContainer(c); });
        }
    };
    Animation.prototype.setFrom = function (from) {
        if (from.length === this.to.length) {
            this.from = from;
        }
        return this;
    };
    Animation.prototype.do = function (elapsed) {
        var _this = this;
        var update = function (start, target) { return start * (1 - elapsed) + (target) * elapsed; };
        var _loop_1 = function (i) {
            if (!this_1.isActive[i]) {
                return "continue";
            }
            this_1.container[i].residues.forEach(function (res) {
                var key = res.index.toString();
                if (_this.from[i].residues.has(key) && _this.to[i].residues.has(key)) {
                    var fromRes = _this.from[i].residues.get(key);
                    var toRes = _this.to[i].residues.get(key);
                    res
                        .setX(update(fromRes.getX(), toRes.getX()))
                        .setY(update(fromRes.getY(), toRes.getY()));
                }
            });
            this_1.container[i].labels.forEach(function (label) {
                var key = label.residue.index.toString();
                if (_this.from[i].labelTexts.has(key) && _this.to[i].labelTexts.has(key)) {
                    var fromLabelText = _this.from[i].labelTexts.get(key);
                    var toLabelText = _this.to[i].labelTexts.get(key);
                    label.text
                        .setX(update(fromLabelText.getX(), toLabelText.getX()))
                        .setY(update(fromLabelText.getY(), toLabelText.getY()));
                }
                if (_this.from[i].labelLines.has(key) && _this.to[i].labelLines.has(key)) {
                    var fromLabelLine = _this.from[i].labelLines.get(key);
                    var toLabelLine = _this.to[i].labelLines.get(key);
                    label.line
                        .setX1(update(fromLabelLine.getX1(), toLabelLine.getX1()))
                        .setY1(update(fromLabelLine.getY1(), toLabelLine.getY1()))
                        .setX2(update(fromLabelLine.getX2(), toLabelLine.getX2()))
                        .setY2(update(fromLabelLine.getY2(), toLabelLine.getY2()));
                }
            });
        };
        var this_1 = this;
        for (var i = 0; i < this.container.length; ++i) {
            _loop_1(i);
        }
    };
    Animation.prototype.reverse = function () {
        var tmp = this.from;
        this.from = this.to;
        this.to = tmp;
        this.reversed = !this.reversed;
    };
    Animation.prototype.animate = function (rna, duration, after) {
        var _this = this;
        if (after === void 0) { after = function () { }; }
        if (this.isActive.indexOf(true) > -1) {
            var ease_1 = d3.easeCubic;
            var timer_1 = d3.timer(function (t) {
                var elapsed = Math.min(1, ease_1(t / duration));
                _this.do(elapsed);
                rna.draw();
                if (elapsed == 1) {
                    timer_1.stop();
                    after();
                }
            });
        }
        else {
            after();
        }
    };
    Animation.prototype.instant = function () {
        this.do(1);
    };
    Animation.prototype.getActiveContainers = function () {
        var active = [];
        for (var i = 0; i < this.container.length; ++i) {
            if (this.isActive[i]) {
                active.push(this.container[i]);
            }
        }
        return active;
    };
    return Animation;
}());
export { Animation };
var VisibilityRecord = /** @class */ (function () {
    function VisibilityRecord(residues, to) {
        this.active = true;
        if (residues.length !== to.length) {
            throw new Error('residues.length !== to.length');
        }
        this.residues = residues;
        this.to = to;
    }
    VisibilityRecord.prototype.setActive = function (active) {
        this.active = active;
    };
    VisibilityRecord.prototype.isActive = function () {
        return this.active;
    };
    return VisibilityRecord;
}());
export { VisibilityRecord };
var VisibilityAnim = /** @class */ (function () {
    function VisibilityAnim(visibilityRecords) {
        this.visibilityRecords = visibilityRecords;
    }
    VisibilityAnim.prototype.changeState = function (index, active) {
        this.visibilityRecords[index].setActive(active);
    };
    VisibilityAnim.prototype.do = function (elapsed) {
        this.visibilityRecords.forEach(function (rec) {
            if (rec.residues.length > elapsed) {
                rec.residues[elapsed].setVisible(rec.to[elapsed]);
            }
        });
    };
    VisibilityAnim.prototype.reverse = function () {
        this.visibilityRecords.forEach(function (rec) {
            rec.to = rec.to.map(function (t) { return !t; });
        });
    };
    VisibilityAnim.prototype.animate = function (rna, duration, after) {
        var _this = this;
        if (after === void 0) { after = function () { }; }
        if (duration <= 0) {
            this.instant();
            rna.draw();
            after();
            return;
        }
        var max = this.maxIndex();
        var i = 0;
        var interval = d3.interval(function () {
            _this.do(i);
            rna.draw();
            ++i;
            if (i >= max) {
                interval.stop();
                after();
            }
        }, duration);
    };
    VisibilityAnim.prototype.instant = function () {
        var _this = this;
        var max = this.maxIndex();
        if (max > 0) {
            Array.from(Array(max).keys()).forEach(function (i) { return _this.do(i); });
        }
    };
    VisibilityAnim.prototype.maxIndex = function () {
        var max = Math.max.apply(Math, this.visibilityRecords.map(function (rec) { return rec.residues.length; }));
        return max;
    };
    return VisibilityAnim;
}());
export { VisibilityAnim };
//# sourceMappingURL=animation.js.map