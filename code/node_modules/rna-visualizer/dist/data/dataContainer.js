import * as d3 from 'd3';
import { Vector2 } from '../components';
import { Styles } from '../styles';
/**
 * Represents a container that holds data for rendering a visualization.
 */
export class DataContainer {
    /**
     * Initializes a new instance of the DataContainer class.
     * @param residues - The residues to render.
     * @param basePairs - The base pairs to render.
     * @param labels - The labels to render.
     * @param styles - The styles to apply.
     */
    constructor(residues, basePairs, labels, styles) {
        this.residues = residues;
        this.basePairs = basePairs;
        this.labels = labels;
        this.styles = styles;
    }
    /**
     * Gets an array of ILine objects that represent the lines to render.
     * @returns An array of ILine objects.
     */
    getLines() {
        return this.basePairs
            .concat(this.labels.map(l => l.line));
    }
    /**
     * Gets an array of Text objects that represent the text to render.
     * @returns An array of Text objects.
     */
    getText() {
        return (this.residues.map(r => r.text))
            .concat(this.labels.map(l => l.text));
    }
    /**
     * Gets an array of Circle objects that represent the circles to render.
     * @returns An array of Circle objects.
     */
    getCircles() {
        return this.residues.map(r => r.circle);
    }
    /**
     * Updates the visualization with the specified event.
     * @param event - The event to use for the update.
     */
    update(event) {
        const width = this.width;
        const height = this.height;
        const x = d3.scaleLinear().domain([0, width]).range([0, width]);
        const y = d3.scaleLinear().domain([0, height]).range([0, height]);
        x.range([0, width].map(d => event.transform.applyX(d)));
        y.range([0, height].map(d => event.transform.applyY(d)));
        const transform = { applyX: x, applyY: y };
        this.residues.forEach((res) => {
            res.setTransform(transform);
            res.circle.setScale(event.transform.k);
        });
        this.labels.forEach((label) => {
            label.setTransform(transform);
        });
        this.styles.set(Styles.TRANSFORMED_CLASS, { k: event.transform.k });
    }
    /**
     * Gets the residue at the specified coordinates.
     * @param x - The x-coordinate.
     * @param y - The y-coordinate.
     * @returns The residue at the specified coordinates, or null if no such residue exists.
     */
    getResByCoor(x, y) {
        let result = null;
        this.residues.find((res) => {
            const resStyles = this.styles.get(res.getClasses());
            const k = resStyles['k'] || 1;
            const shift = (+resStyles['font-size'].slice(0, -2) || 7) * k / 2;
            if (x >= res.getTransformedX() - shift
                && x <= res.getTransformedX() + shift
                && y >= res.getTransformedY() - shift
                && y <= res.getTransformedY() + shift) {
                result = res;
            }
        });
        return result;
    }
    /**
     * Gets the closest residue to the specified coordinates within the specified maximum distance.
     * @param x - The x-coordinate.
     * @param y - The y-coordinate.
     * @param maxDistance - The maximum distance from the specified coordinates.
     * @returns The closest residue to the specified coordinates within the specified maximum distance, or null if no such residue exists.
     */
    getClosestResByCoor(x, y, maxDistance = 100) {
        let result = null;
        let resultDistance = Number.MAX_SAFE_INTEGER;
        const clickPosition = new Vector2(x, y);
        this.residues.forEach((res) => {
            const resCoor = res.getTransformedCoor();
            const distance = Vector2.distance(clickPosition, resCoor);
            if (distance < resultDistance) {
                result = res;
                resultDistance = distance;
            }
        });
        result = resultDistance <= maxDistance ? result : null;
        return result;
    }
    /**
     * Gets an array of residues that cannot be mapped to a template.
     * @returns An array of unmappable residues.
     */
    getUnmappableResidues() {
        return this.residues.filter(res => res.templateIndex === -1);
    }
    /**
     * Gets an array of residues that can be mapped to a template.
     * @returns An array of mappable residues.
     */
    getMappableResidues() {
        return this.residues.filter(res => res.templateIndex !== -1);
    }
    /**
     * Translates the objects by the specified amount.
     * @param shift - The amount to translate the visualization.
     */
    translate(shift) {
        this.residues.forEach(res => {
            res.translate(shift);
        });
        this.labels.forEach(label => {
            label.translate(shift);
        });
    }
}
//# sourceMappingURL=dataContainer.js.map